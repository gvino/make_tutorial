# Простая инструкция по написанию Makefile

_Этот текст является вольным переводом статьи <https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor>_

`Makefile` -- это простой способ для организации процесса компиляции программ.

Данная инструкция не покрывает и сотой доли того, что можно сделать с помощью утилиты `make`, но призвана служить простым пошаговым руководством для новичков, с помощью которого можно создавать собственные `Makefile` для небольших проектов.

_**Замечание для студентов МФТИ.** Со временем вам понядобится писать статьи с использованием системы `LaTeX`. `Makefile` можно использовать и для их сборки._

## 1. Простой пример

Начнем с проекта из трех файлов: `hellomake.c`, `hellofunc.c` и `hellomake.h`, которые будут изображать основной файл программы, дополнительные функции в отдельном файле и заголовочный файл соответственно. Исполняемый файл этой программы будет называться `hellomake`.

`hellomake.c`:

```c
#include "hellomake.h"

int main(void) {
  // Вызов функции из другого файла
  myPrintHelloMake();

  return 0;
}
```

`hellofunc.c`:

```c
#include <stdio.h>
#include "hellomake.h"

void myPrintHelloMake(void) {
  printf("Hello makefiles!\n");

  return;
}
```

`hellomake.h`:

```c
/*
 * Пример заголовочного файла
 */

#pragma once

void myPrintHelloMake(void);
```

Обычно, мы бы компилировали этот набор файлов, используя следующую команду:

    gcc -o hellomake hellomake.c hellofunc.c -I.

Она комилирует и линкует два `.c` файла и создает исполняемый файл `hellomake`.  Опция `-I.` добавлена для того, чтобы `gcc` искал заголовочные файлы в текущей директории (это позволяет писать `#include <hellomake.h>` вместо `#include "hellomake.h"`). Без `Makefile` обычный подход к компиляции, запуску и проверке заключается в нажатии стрелки вверх в терминале до тех пор, пока не отобразится предыдущая команда компиляции, так что нам не надо вводить ее каждый раз до тех пор, пока мы не добавим новые `.c` файлы.

К сожалению, такой подход к компиляции имеет два недостатка. Во-первых, если команда компиляции пропадет или вы будете работать на другом компьютере, команду надо будет набирать заново, что очень неэффективно. Во-вторых, если изменился всего один `.c` файл, пересобирать все остальные не имеет никакого смысла. Теперь посмотрим, как можно решить эти проблемы с помощью `Makefile` и команды `make`.

Простейший `Makefile` будет выглядеть следующим образом:

```makefile
# Makefile 1

hellomake: hellomake.c hellofunc.c
    gcc -o hellomake hellomake.c hellofunc.c -I.
```

Если поместить этот текст в файл, названный `Makefile` или `makefile` (второй вариант не рекомендуется), а потом набрать команду `make` в терминале, то запустится команда компиляции, которую мы написали в файле. Обратите внимание, что `make`, вызванный без аргументов, выполняет первое правило в файле. Более того, так как мы указали список файлов, от которых зависит правило в первой строке команды после знака `:`, команда `make` знает, что правило `hellomake` должно быть выполнено если любой из этих файлов изменился.  Сразу же мы решили первую проблему, так как больше не надо искать команду компиляции в истории команд, написать `make` будет заведомо быстрее. Однако, проблема с компиляцией только изменившихся файлов все-еще актуальна.

Очень важно запомнить, что перед командой `gcc` в `Makefile` стоит табуляция, а не пробелы. Табуляция должна стоять перед каждой командой.

## 2. Компилируем только изменившиеся файлы

Для того, чтобы все работало чуть более эффективно, попробуем следующее:

```makefile
# Makefile 2

CC=gcc
CFLAGS=-I.

hellomake: hellomake.o hellofunc.o
    $(CC) -o hellomake hellomake.o hellofunc.o
```

Мы описали специальные константы (макросы) `CC` и `CFLAGS`, для того, чтобы объяснить `make` как мы хотим компилировать файлы `hellomake.c` и `hellofunc.c`.  Макрос `CC` это компилятор, который будет использоваться, а `CFLAGS` -- список опций, которые будут передаваться компилятору. Размещая объектные файлы (`hellomake.o` и `hellofunc.o`) в списке зависимостей правила, мы сообщаем `make`, что сначала надо скомпилировать по отдельности `.c` файлы, а затем слинковать их в исполняемый файл `hellomake`.

Такая форма `Makefile` практически достаточна для большинства маленьких проектов. Однако нам не хватает одной детали: зависимости от заголовочных файлов. Если изменить `hellomake.h`, `make` не пересоберет `.c` файлы, даже если это необходимо.

## 3. Добавляем зависимость от заголовочных файлов (A.K.A. немного магии)

Для того, чтобы решить проблему из предыдущего пункта, нам нужно указать `make`, что все `.c` файлы зависят от определенных `.h` файлов (_**Замечание**. Из этого следует, что при изменении заголовочных файлов будут перекомпилированы **все** `.c` файлы. Это значит, что прорабатывать интерфейсы следует с особой тщательностью._). Для этого мы добавим простое правило и внесем его в `Makefile`.

```makefile
# Makefile 3

CC=gcc
CFLAGS=-I.
DEPS=hellomake.h

%.o: %.c $(DEPS)
    $(CC) -c -o $@ $< $(CFLAGS)

hellomake: hellomake.o hellofunc.o
    $(CC) -o hellomake hellomake.o hellofunc.o
```

Здесь сначала создается константа `DEPS`, в которой перечисляются все `.h` файлы, от которых зависят `.c` файлы. Далее определяется правило, которое применяется ко всем файлам, имеющим расширение `.o`. Оно говорит, что каждый `.o` файл зависит от соответствующего `.c` файла и `.h` файлов, перечисленных в `DEPS`. Далее правило говорит, что для создания `.o` файла нужно скомпилировать `.c` файлы используя компилятор, указанный в `CC`. Флаг `-c` говорит, что нужно создать объектный файл, `-o $@` -- положить результат компиляции в файл имя которого указано слева от `:`, `$<` -- первый элемент из списка зависимости правила, а макрос `CFLAGS` уже был описан ранее.

## 4. Делаем немного аккуратнее (A.K.A. больше магии)

Для того, чтобы избавиться от перечисления файлов в командах, воспользуемся макросами `$@` и `$^`, которые обозначают то, что слева и то, что справа от `:` соответственно. Это поможет сделать правила более аккуратными и упростить добавление новых файлов в проект. В следующем примере все заголовочные файлы должны быть перечислены в константе `DEPS`, а все объектные файлы -- `OBJ`.

```makefile
# Makefile 4

CC=gcc
CFLAGS=-I.
DEPS = hellomake.h
OBJ = hellomake.o hellofunc.o

%.o: %.c $(DEPS)
    $(CC) -c -o $@ $< $(CFLAGS)

hellomake: $(OBJ)
    $(CC) -o $@ $^ $(CFLAGS)
```

## 5. Структурируем проект

Что, если мы хотим избежать мешанины файлов и хранить `.h` файлы в папке `include`, `.c` файлы в папке `src`, а также можем ли мы как-то убрать мешающие `.o` файлы, болтающиеся среди файлов с кодом? Конечно, это реально. `Makefile` далее определяет пути к папкам `include` и `src`, а также размещает объектные файлы в папку `obj`. Также, в нем определены костанты для библиотек, которые должны быть подключены, например, `math` (`-lm`). Этот `Makefile` должен быть расположен в корне проекта. Также обратите внимание, что он содержит отдельное правило для удаления временных и объектных файлов, которое вызывается, если набрать `make clean`. Правило `.PHONY` запрещает `make` делать что-либо с файлом, называющимся `clean`.

```makefile
# Makefile 5

IDIR=include
CC=gcc
CFLAGS=-I$(IDIR)

SDIR=src
ODIR=obj

LIBS=-lm

_DEPS = hellomake.h
DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))

_OBJ = hellomake.o hellofunc.o
OBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))

.PHONY: clean

$(ODIR)/%.o: $(SDIR)/%.c $(DEPS)
    $(CC) -c -o $@ $< $(CFLAGS)

hellomake: $(OBJ)
    $(CC) -o $@ $^ $(CFLAGS) $(LIBS)

clean:
    rm -f $(ODIR)/*.o $(SDIR)/*~ $(INCDIR)/*~
```

Структура файлов проекта в этом случае будет следующей:

    my_project/
    |__Makefile
    |__src/
    |  |__hellomake.c
    |  |__hellofunc.c
    |__include/
    |  |__hellomake.h
    |__obj/
       |__hellomake.o
       |__hellofunc.o

## 6. Последние штрихи

Несмотря на то, что последний `Makefile` работает, стоит сделать его более соответствующим общепринятым правилам. По соглашению, цель по умолчанию называется `all` и выполняет все действия, которые требуются для того, чтобы получить готовую к работе программу. Эти действия могут включать в себя не только компиляцию исполняемого файла (или файлов, если проект состоит из нескольких программ), но и генерацию файлов конфигурации, документации и так далее. С другой стороны, нам необходимо иметь возможность собрать исполняемый файл без выполнения этих действий. Выход -- создать пустое правило `all`, зависимостью которого указать наш исполняемый файл.

Также, сделаем небольшую корректировку и вынесем имя исполняемого файла в переменную, что позволит нам легко переименовать его при необходимости.

```makefile
# Makefile 6

IDIR=include
CC=gcc
CFLAGS=-I$(IDIR)
BIN=hellomake

SDIR=src
ODIR=obj

LIBS=-lm

_DEPS = hellomake.h
DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))

_OBJ = hellomake.o hellofunc.o
OBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))

.PHONY: all clean

all: $(BIN)

$(ODIR)/%.o: $(SDIR)/%.c $(DEPS)
    $(CC) -c -o $@ $< $(CFLAGS)

$(BIN): $(OBJ)
    $(CC) -o $@ $^ $(CFLAGS) $(LIBS)

clean:
    rm -f $(ODIR)/*.o $(SDIR)/*~ $(INCDIR)/*~
```

## Заключение

Теперь у вас есть отличный `Makefile`, который вы можете использовать на небольших проектах, возможно, добавляя новые правила. Можно даже добавлять правила, которые вызывают другие правила (на самом деле, мы это уже делали: наше правило `all` вызывает правило `hellomake`, а сам `hellomake` вызывает правила для создания `.o` файлов).

Если вам нужно больше информации по `Makefile` и команде `make`, обратитесь к официальной документации GNU Make, из которой вы узнаете гораздо больше, чем когда-либо хотели. Правда.
